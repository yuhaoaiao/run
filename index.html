<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pose Master: Ultimate Challenge</title>
    <link href="https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Luckiest+Guy&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        :root { --u-blue: #009dff; --u-gold: #ffcc00; --u-red: #ff3b3b; --u-green: #4CAF50; }
        body { margin: 0; background: #87ceeb; overflow: hidden; font-family: 'Luckiest Guy', cursive; }
        
        /* ÂÖ®Â±èÈÅÆÁΩ©Â±Ç (Áî®‰∫éÂä†ËΩΩ„ÄÅËèúÂçï„ÄÅÁªìÁÆó) */
        .overlay { 
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; 
            z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(135, 206, 235, 0.95); transition: 0.5s;
        }

        /* ÈöæÂ∫¶ÈÄâÊã©ÊåâÈíÆ */
        .menu-card { background: #fff; padding: 40px; border-radius: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); text-align: center; }
        .btn-group { display: flex; gap: 15px; margin-top: 25px; }
        .btn { 
            padding: 15px 30px; border: none; border-radius: 15px; font-size: 1.5rem; 
            cursor: pointer; font-family: 'Luckiest Guy'; color: white; transition: 0.2s;
            pointer-events: auto;
        }
        .btn-easy { background: var(--u-green); }
        .btn-medium { background: var(--u-gold); }
        .btn-hard { background: var(--u-red); }
        .btn:hover { transform: scale(1.1); filter: brightness(1.1); }

        /* Ê∏∏ÊàèËøêË°å UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; color: white; display: none; }
        #timer-panel { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; }
        #timer-val { font-size: 5rem; line-height: 1; }
        #score-panel { position: absolute; bottom: 40px; right: 40px; text-align: right; }
        #score-val { font-size: 4rem; color: var(--u-gold); -webkit-text-stroke: 1.5px #000; }

        /* ÊëÑÂÉèÂ§¥Â∞èÁ™ó - Ëß£ÂÜ≥ÊîæÂ§ßÈóÆÈ¢ò */
        #video-container { 
            position: absolute; top: 20px; right: 20px; width: 220px; 
            aspect-ratio: 4/3; border: 4px solid #fff; border-radius: 15px; 
            overflow: hidden; transform: scaleX(-1); background: #333; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #input_video { width: 100%; height: 100%; object-fit: contain; } /* contain Á°Æ‰øùÂÖ®ÊôØÊòæÁ§∫ */

        #flash-msg { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); font-size: 6rem; opacity: 0; transition: 0.2s; text-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #flash-msg.show { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    </style>
</head>
<body>

<div id="start-screen" class="overlay">
    <div class="menu-card">
        <h1 style="color: var(--u-blue); font-size: 3.5rem; margin: 0;">POSE MASTER</h1>
        <p style="color: #666; font-size: 1.2rem;">ÈÄâÊã©ÈöæÂ∫¶ÂºÄÂêØË∑ëÈÖ∑ÊåëÊàò</p>
        <div id="loading-msg" style="color: var(--u-red); margin: 10px;">Ê≠£Âú®ËøûÊé• AI ‰º†ÊÑüÂô®...</div>
        <div class="btn-group" id="btn-group" style="display: none;">
            <button class="btn btn-easy" onclick="startGame('EASY')">EASY</button>
            <button class="btn btn-medium" onclick="startGame('MEDIUM')">MEDIUM</button>
            <button class="btn btn-hard" onclick="startGame('HARD')">HARD</button>
        </div>
    </div>
</div>

<div id="end-screen" class="overlay" style="display: none;">
    <div class="menu-card">
        <h1 style="color: var(--u-red); font-size: 4rem; margin: 0;">TIME UP!</h1>
        <div style="font-size: 2.5rem; margin: 20px 0;">SCORE: <span id="final-score" style="color: var(--u-gold);">0</span></div>
        <button class="btn btn-easy" style="background: var(--u-blue);" onclick="location.reload()">RETRY</button>
    </div>
</div>

<div id="ui-layer">
    <div id="timer-panel"><div id="timer-val">60</div></div>
    <div style="position: absolute; bottom: 40px; left: 40px; font-size: 3rem;">üî• X <span id="combo-num">0</span></div>
    <div id="score-panel">
        <div id="score-val">‚òÖ 0000</div>
        <div style="font-size: 1rem; color: #fff;">WALLS PASSED: <span id="walls-passed">0</span></div>
    </div>
    <div id="flash-msg">GREAT!</div>
</div>

<div id="video-container"><video id="input_video" playsinline muted></video></div>
<div id="game-canvas"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/" } } </script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ========================
// 1. Â§çÂè§Èü≥Êïà (Retro SFX)
// ========================
const AudioSys = {
    ctx: null,
    init() { if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    play(type) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        const now = this.ctx.currentTime;
        if (type === 'coin') {
            osc.type = 'square'; osc.frequency.setValueAtTime(987, now); osc.frequency.setValueAtTime(1318, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'hit') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(50, now + 0.3);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        }
    }
};

// ========================
// 2. 3D ÁéØÂ¢ÉÊûÑÂª∫
// ========================
let scene, camera, renderer, composer, wall, ghostGroup, skeletonLines, track, trees = [];
let score = 0, combo = 0, wallsPassed = 0, timeLeft = 60, isGameOver = false, isHit = false;
let gameSpeed = 0.3, currentPoseKey = 'T-POSE', diffMultiplier = 1;

function init3D() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb); scene.fog = new THREE.Fog(0x87ceeb, 20, 100);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-canvas').appendChild(renderer.domElement);
    composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.4, 0.85));

    const loader = new THREE.TextureLoader();
    const gridTex = loader.load('https://threejs.org/examples/textures/grid.png');
    gridTex.wrapS = gridTex.wrapT = THREE.RepeatWrapping; gridTex.repeat.set(1, 20);
    track = new THREE.Mesh(new THREE.PlaneGeometry(12, 400), new THREE.MeshPhongMaterial({ map: gridTex, color: 0x444444 }));
    track.rotation.x = -Math.PI / 2; scene.add(track);

    const grass = new THREE.Mesh(new THREE.PlaneGeometry(200, 400), new THREE.MeshPhongMaterial({ color: 0x7cfc00 }));
    grass.rotation.x = -Math.PI / 2; grass.position.y = -0.05; scene.add(grass);

    for(let i=0; i<30; i++) {
        const tree = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.2), new THREE.MeshPhongMaterial({color: 0x8b4513}));
        const leaves = new THREE.Mesh(new THREE.ConeGeometry(1, 2.5, 6), new THREE.MeshPhongMaterial({color: 0x228b22}));
        leaves.position.y = 1.5; tree.add(trunk, leaves); tree.position.set(i % 2 === 0 ? -15 : 15, 0, -i * 20);
        scene.add(tree); trees.push(tree);
    }

    ghostGroup = new THREE.Group();
    for(let i=0; i<33; i++) ghostGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0x00f2ff })));
    skeletonLines = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x00f2ff }));
    ghostGroup.add(skeletonLines); scene.add(ghostGroup);

    scene.add(new THREE.AmbientLight(0xffffff, 1.2), new THREE.DirectionalLight(0xffffff, 0.8));
    camera.position.set(0, 3, 10);
}

function createHollowTexture(poseKey) {
    const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#008cff'; ctx.fillRect(0, 0, 512, 512);
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineWidth = 20; ctx.lineCap = 'round'; ctx.translate(256, 256); ctx.scale(4.2, 4.2); ctx.translate(-50, -50);
    ctx.beginPath(); ctx.arc(50, 18, 8, 0, Math.PI * 2);
    if(poseKey === 'T-POSE') { ctx.moveTo(15, 42); ctx.lineTo(85, 42); ctx.moveTo(50, 32); ctx.lineTo(50, 75); ctx.moveTo(50, 75); ctx.lineTo(35, 95); ctx.moveTo(50, 75); ctx.lineTo(65, 95); }
    else if(poseKey === 'V-SHAPE') { ctx.moveTo(50, 32); ctx.lineTo(25, 12); ctx.moveTo(50, 32); ctx.lineTo(75, 12); ctx.moveTo(50, 32); ctx.lineTo(50, 75); ctx.moveTo(50, 75); ctx.lineTo(35, 95); ctx.moveTo(50, 75); ctx.lineTo(65, 95); }
    else { ctx.moveTo(50, 32); ctx.lineTo(20, 32); ctx.moveTo(50, 32); ctx.lineTo(80, 15); ctx.moveTo(50, 32); ctx.lineTo(50, 75); ctx.moveTo(50, 75); ctx.lineTo(30, 95); ctx.moveTo(50, 75); ctx.lineTo(75, 85); }
    ctx.stroke(); return new THREE.CanvasTexture(canvas);
}

function spawnWall() {
    if(wall) scene.remove(wall); isHit = false;
    currentPoseKey = ['T-POSE', 'V-SHAPE', 'ARCHER'][Math.floor(Math.random()*3)];
    wall = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 0.5), new THREE.MeshPhongMaterial({ map: createHollowTexture(currentPoseKey), transparent: true }));
    wall.position.set(0, 4, -100); scene.add(wall);
}

// ========================
// 3. Ê†∏ÂøÉÊ∏∏ÊàèÊéßÂà∂
// ========================
window.startGame = (diff) => {
    AudioSys.init();
    if(diff === 'EASY') { gameSpeed = 0.3; diffMultiplier = 1; }
    else if(diff === 'MEDIUM') { gameSpeed = 0.5; diffMultiplier = 1.5; }
    else { gameSpeed = 0.7; diffMultiplier = 2; }
    
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('ui-layer').style.display = 'block';
    
    // ÂêØÂä®ËÆ°Êó∂Âô®
    const timer = setInterval(() => {
        if(timeLeft > 0) {
            timeLeft--;
            document.getElementById('timer-val').innerText = timeLeft;
        } else {
            clearInterval(timer);
            endGame();
        }
    }, 1000);
    spawnWall();
};

function endGame() {
    isGameOver = true;
    document.getElementById('ui-layer').style.display = 'none';
    document.getElementById('end-screen').style.display = 'flex';
    document.getElementById('final-score').innerText = score;
}

function handleResult(success) {
    if(isHit) return; isHit = true;
    if(success) {
        score += Math.round(300 * diffMultiplier); combo++; timeLeft += 2; wallsPassed++;
        AudioSys.play('coin');
        document.getElementById('flash-msg').innerText = "GREAT! +2s";
        gameSpeed += 0.01;
    } else {
        combo = 0; AudioSys.play('hit');
        document.getElementById('flash-msg').innerText = "MISS!";
        gameSpeed -= 0.02; if(gameSpeed < 0.3) gameSpeed = 0.3;
    }
    document.getElementById('flash-msg').classList.add('show');
    document.getElementById('score-val').innerText = "‚òÖ " + score.toString().padStart(4, '0');
    document.getElementById('combo-num').innerText = combo;
    document.getElementById('walls-passed').innerText = wallsPassed;
    setTimeout(() => { document.getElementById('flash-msg').classList.remove('show'); spawnWall(); }, 600);
}

// ========================
// 4. AI Êò†Â∞Ñ‰∏éÂæ™ÁéØ
// ========================
const CONNECTIONS = [[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[25,27],[24,26],[26,28]];
const getA = (p1, p2) => Math.atan2(p2.y-p1.y, p2.x-p1.x)*(180/Math.PI);

async function setupAI() {
    const pose = new Pose({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`});
    pose.setOptions({ modelComplexity: 1, minDetectionConfidence: 0.6 });
    pose.onResults(res => {
        if(!res.poseLandmarks) return;
        document.getElementById('loading-msg').innerText = "AI Â∞±Áª™ÔºÅËØ∑ÈÄâÊã©ÈöæÂ∫¶Ôºö";
        document.getElementById('btn-group').style.display = 'flex';

        // Êò†Â∞Ñ‰øÆÂ§çÔºöË∞ÉÊï¥Á≥ªÊï∞‰Ωø‰∫∫‰ΩìÊØî‰æãËá™ÁÑ∂
        const lm = res.poseLandmarks;
        lm.forEach((pt, i) => {
            ghostGroup.children[i].position.set((0.5 - pt.x)*14, (0.5 - pt.y)*10 + 2, 2.5);
        });
        const linePos = [];
        CONNECTIONS.forEach(([i,j]) => {
            const p1 = ghostGroup.children[i].position, p2 = ghostGroup.children[j].position;
            linePos.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        });
        skeletonLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
        
        if(!isGameOver && wall && !isHit) {
            const matched = {
                'T-POSE': () => Math.abs(getA(lm[11], lm[15])) < 25,
                'V-SHAPE': () => lm[15].y < lm[11].y,
                'ARCHER': () => Math.abs(getA(lm[11], lm[13])) < 20
            }[currentPoseKey]();
            if(wall.position.z > 3 && wall.position.z < 8.5 && matched) handleResult(true);
        }
    });
    const cam = new Camera(document.getElementById('input_video'), { onFrame: async () => { await pose.send({image: document.getElementById('input_video')}); }, width: 640, height: 480 });
    cam.start();
}

function animate() {
    if(isGameOver) return; requestAnimationFrame(animate);
    if(track) track.material.map.offset.y -= gameSpeed * 0.15;
    trees.forEach(t => { t.position.z += gameSpeed * 5; if(t.position.z > 20) t.position.z = -180; });
    if(wall) { wall.position.z += gameSpeed * 2.5; if(wall.position.z > 15 && !isHit) handleResult(false); }
    composer.render();
}

init3D(); setupAI(); animate();
</script>
</body>
</html>