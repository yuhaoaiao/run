<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pose Master Rush: Visual Instruction Edition</title>
    <link href="https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #050010; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; color: #fff; }
        .hud { position: absolute; padding: 20px; text-shadow: 0 0 15px #00f2ff; }
        #score-panel { bottom: 20px; right: 20px; text-align: right; font-size: 2.5rem; }
        #combo-panel { bottom: 20px; left: 20px; font-size: 2rem; color: #ff00ff; }
        #video-preview { position: absolute; top: 20px; right: 20px; width: 180px; border: 2px solid #00f2ff; border-radius: 8px; transform: scaleX(-1); opacity: 0.8; }
        #msg-popup { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5rem; font-weight: 900; opacity: 0; transition: 0.3s; pointer-events: none; }
        #loading { position: absolute; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 100; color: #00f2ff; font-size: 1.5rem; }
    </style>
</head>
<body>

<div id="loading">AI 视觉神经元加载中... (请确保开启摄像头)</div>

<div id="ui">
    <div id="score-panel" class="hud">SCORE: <span id="score">0</span></div>
    <div id="combo-panel" class="hud">COMBO: <span id="combo">0</span></div>
    <div id="msg-popup">PERFECT</div>
</div>

<video id="video-preview" autoplay playsinline></video>
<div id="game-canvas"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ========================
// 1. 姿态定义与绘制逻辑 (Instruction Generator)
// ========================
const POSE_DEFS = {
    'T-POSE': (ctx) => { line(ctx, 50,50, 20,50); line(ctx, 50,50, 80,50); line(ctx, 50,50, 50,85); }, // T字
    'V-SHAPE': (ctx) => { line(ctx, 50,50, 25,20); line(ctx, 50,50, 75,20); line(ctx, 50,50, 50,85); }, // V字
    'L-RIGHT': (ctx) => { line(ctx, 50,50, 50,20); line(ctx, 50,50, 80,50); line(ctx, 50,50, 50,85); }, // L字(右)
    'L-LEFT': (ctx) => { line(ctx, 50,50, 50,20); line(ctx, 50,50, 20,50); line(ctx, 50,50, 50,85); }, // L字(左)
    'FLEX': (ctx) => { line(ctx, 50,55, 30,35); line(ctx, 30,35, 45,20); line(ctx, 50,55, 70,35); line(ctx, 70,35, 55,20); line(ctx, 50,55, 50,90); }, // 肌肉
    'ARCHER': (ctx) => { line(ctx, 50,50, 20,50); line(ctx, 50,50, 55,35); line(ctx, 55,35, 50,25); line(ctx, 50,50, 50,85); }, // 拉弓
    'ZEN': (ctx) => { line(ctx, 50,50, 40,40); line(ctx, 50,50, 60,40); line(ctx, 50,50, 50,90); }, // 禅定
    'DAB': (ctx) => { line(ctx, 50,50, 20,40); line(ctx, 50,50, 80,20); line(ctx, 50,50, 50,85); } // 潮流
};

function line(ctx, x1, y1, x2, y2) {
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
}

function createPoseTexture(poseKey) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // 背景稍微带点透明深色
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, 512, 512);

    // 绘制霓虹小人
    ctx.strokeStyle = '#00f2ff';
    ctx.lineWidth = 15;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#00f2ff';

    ctx.scale(5.12, 5.12); // 缩放到 100x100 的逻辑空间
    ctx.beginPath();
    // 头部
    ctx.arc(50, 15, 8, 0, Math.PI * 2);
    // 身体部位由 POSE_DEFS 决定
    POSE_DEFS[poseKey](ctx);
    ctx.stroke();

    return new THREE.CanvasTexture(canvas);
}

// ========================
// 2. 姿态判定核心 (Vector Logic)
// ========================
function getAngle(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI); }

const PoseValidators = {
    'T-POSE': (lm) => Math.abs(getAngle(lm[11], lm[15])) < 25 && Math.abs(getAngle(lm[12], lm[16])) > 155,
    'V-SHAPE': (lm) => lm[15].y < lm[11].y && lm[16].y < lm[12].y && Math.abs(lm[15].x - lm[16].x) > 0.4,
    'L-RIGHT': (lm) => Math.abs(getAngle(lm[12], lm[16])) > 150 && lm[15].y < lm[11].y,
    'L-LEFT': (lm) => Math.abs(getAngle(lm[11], lm[15])) < 30 && lm[16].y < lm[12].y,
    'FLEX': (lm) => lm[15].y < lm[13].y && lm[16].y < lm[14].y && getAngle(lm[11], lm[13]) < -10,
    'ARCHER': (lm) => Math.abs(getAngle(lm[11], lm[15])) < 20 && Math.abs(lm[16].x - lm[12].x) < 0.1,
    'ZEN': (lm) => Math.hypot(lm[15].x-lm[16].x, lm[15].y-lm[16].y) < 0.1,
    'DAB': (lm) => lm[15].y < lm[11].y && Math.abs(getAngle(lm[11], lm[15])) > 130
};

// ========================
// 3. 3D 引擎与核心逻辑
// ========================
let scene, camera, renderer, composer, wallGroup;
let currentPoseKey = 'T-POSE', score = 0, combo = 0, speed = 0.6;

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-canvas').appendChild(renderer.domElement);

    // 霓虹后期
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    composer.addPass(bloom);

    // 地面网格
    const grid = new THREE.GridHelper(400, 60, 0x00f2ff, 0x002233);
    grid.rotation.x = Math.PI/2;
    scene.add(grid);

    spawnWall();
    camera.position.set(0, 1.8, 10);
    animate();
}

function spawnWall() {
    if(wallGroup) scene.remove(wallGroup);
    
    currentPoseKey = Object.keys(POSE_DEFS)[Math.floor(Math.random() * 8)];
    const texture = createPoseTexture(currentPoseKey);

    wallGroup = new THREE.Group();
    
    // 主墙体 (半透明力场)
    const wallGeo = new THREE.BoxGeometry(10, 10, 0.2);
    const wallMat = new THREE.MeshBasicMaterial({ color: 0x002244, transparent: true, opacity: 0.4 });
    const wallBase = new THREE.Mesh(wallGeo, wallMat);
    
    // 姿态剪影面 (核心指令)
    const silGeo = new THREE.PlaneGeometry(6, 6);
    const silMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
    const silhouette = new THREE.Mesh(silGeo, silMat);
    silhouette.position.z = 0.11; // 贴在墙面上

    wallGroup.add(wallBase, silhouette);
    wallGroup.position.z = -120;
    wallGroup.position.y = 1.5;
    scene.add(wallGroup);
}

// AI 识别接入
const pose = new Pose({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`});
pose.setOptions({ modelComplexity: 1, minDetectionConfidence: 0.6 });
pose.onResults(res => {
    document.getElementById('loading').style.display = 'none';
    if(!res.poseLandmarks || !wallGroup || wallGroup.userData.hit) return;
    
    const matched = PoseValidators[currentPoseKey](res.poseLandmarks);
    // 判定区域: 距离相机 3-8 米
    if(wallGroup.position.z > 3 && wallGroup.position.z < 8) {
        if(matched) handleResult(true);
    }
});

function handleResult(isSuccess) {
    wallGroup.userData.hit = true;
    const msg = document.getElementById('msg-popup');
    if(isSuccess) {
        score += 100; combo++;
        msg.innerText = "PERFECT!"; msg.style.color = "#00f2ff";
        // 瞬间加速效果
        speed += 0.02;
    } else {
        combo = 0;
        msg.innerText = "MISS!"; msg.style.color = "#ff0055";
        speed = 0.6; // 重置速度
    }
    msg.style.opacity = 1;
    setTimeout(() => msg.style.opacity = 0, 500);
    
    document.getElementById('score').innerText = score;
    document.getElementById('combo').innerText = combo;
    spawnWall();
}

function animate() {
    requestAnimationFrame(animate);
    if(wallGroup) {
        wallGroup.position.z += speed;
        // 漏掉墙体判定为失败
        if(wallGroup.position.z > 12 && !wallGroup.userData.hit) handleResult(false);
    }
    composer.render();
}

const cam = new Camera(document.getElementById('video-preview'), {
    onFrame: async () => { await pose.send({image: document.getElementById('video-preview')}); },
    width: 640, height: 480
});
cam.start();
init();
</script>
</body>
</html>