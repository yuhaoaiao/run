<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pose Master: Ghost Alignment Edition</title>
    <link href="https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Luckiest+Guy&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        :root { --ui-blue: #00f2ff; --ui-gold: #ffcc00; --ui-red: #ff3344; }
        body { margin: 0; background: #050510; overflow: hidden; font-family: 'Luckiest Guy', cursive; color: white; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* 倒计时与分数 */
        #timer-panel { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); text-align: center; }
        #timer-val { font-size: 4rem; text-shadow: 0 0 20px var(--ui-blue); }
        #score-panel { position: absolute; bottom: 30px; right: 40px; text-align: right; }
        #score-val { font-size: 3.5rem; color: var(--ui-gold); }

        /* 结算弹窗 */
        #game-over { 
            position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.85); 
            z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; 
            backdrop-filter: blur(10px);
        }
        .result-card { text-align: center; padding: 40px; border: 4px solid var(--ui-blue); border-radius: 20px; background: #000; }
        .restart-btn { margin-top: 20px; padding: 12px 30px; background: var(--ui-blue); border: none; border-radius: 30px; font-family: 'Luckiest Guy'; font-size: 1.5rem; cursor: pointer; pointer-events: auto; }

        /* 提示信息 */
        #flash-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5rem; opacity: 0; transition: 0.3s; }
        #flash-msg.show { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }

        #loading { position: absolute; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body>

<div id="loading">AI 神经元对齐中...</div>

<div id="game-over">
    <div class="result-card">
        <h1 style="color: var(--ui-red); font-size: 3rem;">TIME EXPIRED</h1>
        <p style="font-size: 2rem;">FINAL SCORE: <span id="final-score" style="color: var(--ui-gold);">0</span></p>
        <button class="restart-btn" onclick="location.reload()">再来一局</button>
    </div>
</div>

<div id="ui-layer">
    <div id="timer-panel">
        <div id="timer-val">60</div>
        <div style="font-size: 1rem; letter-spacing: 5px; color: var(--ui-blue);">SECONDS LEFT</div>
    </div>
    <div id="score-panel">
        <div id="score-val">★ 0000</div>
        <div id="combo-text" style="color: var(--ui-blue);">COMBO X 0</div>
    </div>
    <div id="flash-msg">PERFECT</div>
</div>

<div id="game-canvas"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ========================
// 1. 动作指令绘制逻辑
// ========================
const POSE_GUIDES = {
    'T-POSE': (ctx) => { line(ctx, 50,45, 15,45); line(ctx, 50,45, 85,45); line(ctx, 50,45, 50,85); },
    'V-SHAPE': (ctx) => { line(ctx, 50,50, 20,15); line(ctx, 50,50, 80,15); line(ctx, 50,50, 50,85); },
    'L-RIGHT': (ctx) => { line(ctx, 50,50, 50,15); line(ctx, 50,50, 85,50); line(ctx, 50,50, 50,85); },
    'FLEX': (ctx) => { line(ctx, 50,55, 30,35); line(ctx, 30,35, 45,15); line(ctx, 50,55, 70,35); line(ctx, 70,35, 55,15); line(ctx, 50,55, 50,90); }
};
function line(ctx, x1, y1, x2, y2) { ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); }

function createWallTexture(poseKey) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0, 30, 60, 0.9)';
    ctx.fillRect(0, 0, 512, 512);
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 15; ctx.lineCap = 'round';
    ctx.shadowBlur = 20; ctx.shadowColor = '#00f2ff';
    ctx.translate(256, 256); ctx.scale(4, 4); ctx.translate(-50, -50);
    ctx.beginPath(); ctx.arc(50, 15, 8, 0, Math.PI*2); POSE_GUIDES[poseKey](ctx); ctx.stroke();
    return new THREE.CanvasTexture(canvas);
}

// ========================
// 2. 3D 引擎与幽灵残影
// ========================
let scene, camera, renderer, composer, wall, ghostPlayer;
let score = 0, combo = 0, timeLeft = 60, isGameOver = false;
let currentPoseKey = 'T-POSE', gameSpeed = 0.6;

function init3D() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.04);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-canvas').appendChild(renderer.domElement);

    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

    // 创建幽灵残影 (用球体表示关节点)
    ghostPlayer = new THREE.Group();
    for(let i=0; i<33; i++) {
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.6 })
        );
        ghostPlayer.add(sphere);
    }
    scene.add(ghostPlayer);

    const grid = new THREE.GridHelper(400, 50, 0x00f2ff, 0x001122);
    grid.rotation.x = Math.PI/2; scene.add(grid);

    camera.position.set(0, 2, 10);
    spawnWall();
}

function spawnWall() {
    if(wall) scene.remove(wall);
    currentPoseKey = Object.keys(POSE_GUIDES)[Math.floor(Math.random()*4)];
    const tex = createWallTexture(currentPoseKey);
    const group = new THREE.Group();
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 0.2), new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0.4 }));
    const sil = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
    sil.position.z = 0.12; group.add(mesh, sil);
    group.position.z = -120; group.position.y = 2;
    wall = group; scene.add(wall);
}

// ========================
// 3. AI 逻辑与对齐反馈
// ========================
const pose = new Pose({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`});
pose.setOptions({ modelComplexity: 1, minDetectionConfidence: 0.6 });

pose.onResults(res => {
    document.getElementById('loading').style.display = 'none';
    if(!res.poseLandmarks || isGameOver) return;

    // 更新幽灵残影位置 (镜像映射)
    res.poseLandmarks.forEach((lm, i) => {
        const target = ghostPlayer.children[i];
        target.position.x = (0.5 - lm.x) * 10; // 这里的 10 是场景缩放系数
        target.position.y = (0.5 - lm.y) * 8 + 2;
        target.position.z = 2; // 稍微在相机前面
    });

    // 姿态判定
    const getA = (p1, p2) => Math.atan2(p2.y-p1.y, p2.x-p1.x)*(180/Math.PI);
    const lm = res.poseLandmarks;
    const isMatched = {
        'T-POSE': () => Math.abs(getA(lm[11], lm[15])) < 25 && Math.abs(getA(lm[12], lm[16])) > 155,
        'V-SHAPE': () => lm[15].y < lm[11].y && lm[16].y < lm[12].y,
        'L-RIGHT': () => Math.abs(getA(lm[12], lm[16])) > 150 && lm[15].y < lm[11].y,
        'FLEX': () => lm[15].y < lm[13].y && lm[16].y < lm[14].y
    }[currentPoseKey]();

    if(wall.position.z > 3 && wall.position.z < 8 && isMatched && !wall.userData.hit) {
        handleResult(true);
    }
});

function handleResult(success) {
    wall.userData.hit = true;
    const msg = document.getElementById('flash-msg');
    if(success) {
        score += 300; combo++; timeLeft += 2;
        msg.innerText = "PERFECT +2s"; msg.style.color = "var(--ui-blue)";
        gameSpeed += 0.01;
    } else {
        combo = 0; msg.innerText = "MISS!"; msg.style.color = "var(--ui-red)";
        gameSpeed = 0.6;
    }
    msg.classList.add('show');
    setTimeout(() => { msg.classList.remove('show'); spawnWall(); }, 600);
    document.getElementById('score-val').innerText = "★ " + score.toString().padStart(4, '0');
    document.getElementById('combo-num').innerText = combo;
}

// 启动
const video = document.createElement('video');
const cam = new Camera(video, {
    onFrame: async () => { await pose.send({image: video}); },
    width: 640, height: 480
});

function animate() {
    if(isGameOver) return;
    requestAnimationFrame(animate);
    if(wall) {
        wall.position.z += gameSpeed;
        if(wall.position.z > 12 && !wall.userData.hit) handleResult(false);
    }
    composer.render();
}

let timer = setInterval(() => {
    if(timeLeft <= 0) { clearInterval(timer); isGameOver = true; document.getElementById('game-over').style.display = 'flex'; document.getElementById('final-score').innerText = score; }
    else { timeLeft--; document.getElementById('timer-val').innerText = timeLeft; }
}, 1000);

init3D(); cam.start(); animate();
</script>
</body>
</html>